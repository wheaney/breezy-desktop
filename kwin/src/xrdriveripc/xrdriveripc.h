// C++ bridge now invoking xrdriveripc via external python process
#pragma once

#include <string>
#include <map>
#include <variant>
#include <vector>
#include <optional>
#include <QString>
#include <QByteArray>

// Export header generated by CMake (GenerateExportHeader)
#ifdef __has_include
#  if __has_include("xr_driver_ipc_export.h")
#    include "xr_driver_ipc_export.h"
#  endif
#endif

#ifndef XR_DRIVER_IPC_EXPORT
#  define XR_DRIVER_IPC_EXPORT __attribute__((visibility("default")))
#endif

// Simple variant type for config/state key values we care about
using XRValue = std::variant<std::monostate, bool, int, double, std::string>;
using XRDict  = std::map<std::string, XRValue>;

class XR_DRIVER_IPC_EXPORT XRDriverIPCBridge {
public:
	static XRDriverIPCBridge &instance();

	std::optional<XRDict> retrieveConfig();
	std::optional<XRDict> retrieveDriverState();
	bool writeConfig(const XRDict &configUpdate);
	bool writeControlFlags(const std::map<std::string, bool> &flags);
	bool requestToken(const std::string &email);
	bool verifyToken(const std::string &token);

private:
	XRDriverIPCBridge() = default;
	~XRDriverIPCBridge() = default;
	XRDriverIPCBridge(const XRDriverIPCBridge&) = delete;
	XRDriverIPCBridge& operator=(const XRDriverIPCBridge&) = delete;

	std::string configHome() const;
	QByteArray invokePython(const QString &method,
							const QByteArray &payloadJson,
							const QString &singleArg) const;

	bool m_initialized = false;
	QString m_pythonDir; // directory containing xrdriveripc.py
};
